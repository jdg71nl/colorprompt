# ---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++-----
# bash.quicky
# ---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++-----

# d250909:
# file-descriptors :
/dev/stdin  = fd 0
/dev/stdout = fd 1
/dev/stderr = fd 2

# to redir do:
cmd 1> /dev/null
# 1> is the same as >
cmd > /dev/null
# only stderr
cmd 2> /dev/null
# both stdout and stderr (note: the '2>&1' part needs to be AFTER the '1>' part!)
cmd 1> /dev/null 2>&1
Enhancement 3: This is such a common operation, that many shells have a
# shorthand to a single &> operator
cmd &> /dev/null

# d250909-jdg nice explanation here: https://unix.stackexchange.com/questions/119648/redirecting-to-dev-null
" When you run CMD > /dev/null 2>&1
  STDOUT redirects to /dev/null, and then STDERR redirects to THE ADDRESS of STDOUT, which has been set to /dev/null , consequently both STDOUT and STDERR point to /dev/null
  Oppositely, when you run CMD 2>&1 >/dev/null
  STDERR redirects to THE ADDRESS of STDOUT (File descriptor 1 in that moment, or /proc/self/fd/1), and then STDOUT redirects to /dev/null , but STDERR keeps redirecting to fd1! As a result the normal output from STDOUT is discarded, but the errors coming from STDERR are still being written onto the console."


# - - - 
# (jdg-pre-d250909)
# interpreter call in shell scripting (shebang):

# USE this instead of generic "#!/bin/sh" :

	#!/usr/bin/env bash

#!/usr/bin/env bash
#  according to http://en.wikipedia.org/wiki/Shebang_%28Unix%29#Portability
#  it is BETTER to use:
#!/usr/bin/env bash
#  than:
#!/bin/bash

because of portability (env resolves full path)

# ---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++-----
There are two formats for redirecting  standard  output  and  standard error:
format 1: command &>word
format 2: command >&word
Of the two forms, the first is preferred.  This is semantically equiv-alent to
> command >word 2>&1

equivalent examples:
> /bin/ls &>/dev/null
> /bin/ls 1>/dev/null 2>/dev/null
> /bin/ls >/dev/null 2>&1

# ---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++-----
There are two formats for redirecting  standard  output  and  standard error:
global bash config: /etc/bashrc
user specific: ~/.bashrc
example:
> cat ~/.bashrc
	user # .bashrc
	# User specific aliases and functions

	# Source global definitions
	if [ -f /etc/bashrc ]; then
				  . /etc/bashrc
	fi
	#jdg add after global - to set again
	#jdg need group-readable/writealbe because of unison sync
	umask 0002
# ---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++-----
# pause
echo
echo -n 'Press any key to continue'
read

# ---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++-----
# debugging Bash scripts:

bash -x script.sh 

# or inside a script:

set -x			# activate debugging from here
w
set +x			# stop debugging from here

# or in the slash-bang:
#!/bin/bash -x

# ---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++-----
# Ubuntu uses DASH instead of BASH
# See: https://wiki.ubuntu.com/DashAsBinSh

> lt /bin/sh
lrwxrwxrwx 1 root root 4 2008-12-14 12:49 /bin/sh -> dash

replace:
#!/bin/sh
with:
#!/bin/bash

perl -pi -e 's/\/bin\/sh/\/bin\/bash/' *.sh

# ---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++-----
# for loop

for i in `seq 1 10`; do echo $i; done
for i in {1..10}; do echo $i; done

# ---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++---+++-----
